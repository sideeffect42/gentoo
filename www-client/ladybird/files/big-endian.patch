diff --git a/AK/FloatingPointStringConversions.cpp b/AK/FloatingPointStringConversions.cpp
index 9298d62241..63b73f0f2c 100644
--- a/AK/FloatingPointStringConversions.cpp
+++ b/AK/FloatingPointStringConversions.cpp
@@ -176,8 +176,6 @@ static constexpr auto max_representable_power_of_ten_in_u64 = 19;
 static_assert(1e19 <= static_cast<double>(NumericLimits<u64>::max()));
 static_assert(1e20 >= static_cast<double>(NumericLimits<u64>::max()));

-static_assert(HostIsLittleEndian, "Float parsing currently assumes little endian, this fact is only used in fast parsing of 8 digits at a time"
-                                  "\nyou _should_ only need to change read eight_digits to make this big endian compatible.");
 constexpr u64 read_eight_digits(char const* string)
 {
     u64 val;
@@ -206,6 +204,7 @@ constexpr static u32 eight_digits_to_value(u64 value)
 {
     // THIS DOES ABSOLUTELY ASSUME has_eight_digits is true

+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
     // This trick is based on https://johnnylee-sde.github.io/Fast-numeric-string-to-int/
     // FIXME: fast_float uses a slightly different version, but that is far harder
     //        to understand and does not seem to improve performance substantially.
@@ -238,6 +237,19 @@ constexpr static u32 eight_digits_to_value(u64 value)

     // With the example this gives 0x$$$$$$$$00bc614e
     //                                       12345678
+#else
+    value -= 0x3030303030303030;
+
+    value = (value&0x0fL)
+        + ((value&(0x0fL<< 8)) >>  8) *       10
+        + ((value&(0x0fL<<16)) >> 16) *      100
+        + ((value&(0x0fL<<24)) >> 24) *     1000
+        + ((value&(0x0fL<<32)) >> 32) *    10000
+        + ((value&(0x0fL<<40)) >> 40) *   100000
+        + ((value&(0x0fL<<48)) >> 48) *  1000000
+        + ((value&(0x0fL<<56)) >> 56) * 10000000;
+#endif
+
     // Now we just truncate to the lower part
     return u32(value);
 }
diff --git a/AK/StringBase.h b/AK/StringBase.h
index 541f7b8bdd..40eabf2d40 100644
--- a/AK/StringBase.h
+++ b/AK/StringBase.h
@@ -25,7 +25,6 @@ struct ShortString {
     u8 storage[MAX_SHORT_STRING_BYTE_COUNT] = { 0 };
 };

-static_assert(HostIsLittleEndian, "Order of fields in ShortString assumes LE.");
 static_assert(sizeof(ShortString) >= sizeof(StringData*));
 static_assert(__builtin_offsetof(ShortString, byte_count_and_short_string_flag) == 0);

diff --git a/Userland/Libraries/LibWeb/Crypto/CryptoAlgorithms.cpp b/Userland/Libraries/LibWeb/Crypto/CryptoAlgorithms.cpp
index cc485d8a4f..bbe1181c88 100644
--- a/Userland/Libraries/LibWeb/Crypto/CryptoAlgorithms.cpp
+++ b/Userland/Libraries/LibWeb/Crypto/CryptoAlgorithms.cpp
@@ -44,8 +44,6 @@ AlgorithmMethods::~AlgorithmMethods() = default;
 // https://w3c.github.io/webcrypto/#big-integer
 static ::Crypto::UnsignedBigInteger big_integer_from_api_big_integer(JS::GCPtr<JS::Uint8Array> const& big_integer)
 {
-    static_assert(AK::HostIsLittleEndian, "This method needs special treatment for BE");
-
     // The BigInteger typedef is a Uint8Array that holds an arbitrary magnitude unsigned integer
     // **in big-endian order**. Values read from the API SHALL have minimal typed array length
     // (that is, at most 7 leading zero bits, except the value 0 which shall have length 8 bits).
@@ -56,6 +54,7 @@ static ::Crypto::UnsignedBigInteger big_integer_from_api_big_integer(JS::GCPtr<J
     ::Crypto::UnsignedBigInteger result(0);
     if (buffer.size() > 0) {

+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
         // We need to reverse the buffer to get it into little-endian order
         Vector<u8, 32> reversed_buffer;
         reversed_buffer.resize(buffer.size());
@@ -64,6 +63,9 @@ static ::Crypto::UnsignedBigInteger big_integer_from_api_big_integer(JS::GCPtr<J
         }

         result = ::Crypto::UnsignedBigInteger::import_data(reversed_buffer.data(), reversed_buffer.size());
+#else
+        result = ::Crypto::UnsignedBigInteger::import_data(buffer.data(), buffer.size());
+#endif
     }
     return result;
 }
@@ -71,8 +73,6 @@ static ::Crypto::UnsignedBigInteger big_integer_from_api_big_integer(JS::GCPtr<J
 // https://www.rfc-editor.org/rfc/rfc7518#section-2
 ErrorOr<String> base64_url_uint_encode(::Crypto::UnsignedBigInteger integer)
 {
-    static_assert(AK::HostIsLittleEndian, "This code assumes little-endian");
-
     // The representation of a positive or zero integer value as the
     // base64url encoding of the value's unsigned big-endian
     // representation as an octet sequence.  The octet sequence MUST
@@ -87,6 +87,7 @@ ErrorOr<String> base64_url_uint_encode(::Crypto::UnsignedBigInteger integer)

     auto data_slice = bytes.bytes().slice(bytes.size() - data_size, data_size);

+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
     // We need to encode the integer's big endian representation as a base64 string
     Vector<u8, 32> byte_swapped_data;
     byte_swapped_data.ensure_capacity(data_size);
@@ -94,6 +95,9 @@ ErrorOr<String> base64_url_uint_encode(::Crypto::UnsignedBigInteger integer)
         byte_swapped_data.append(data_slice[data_size - i - 1]);

     auto encoded = TRY(encode_base64url(byte_swapped_data));
+#else
+    auto encoded = TRY(encode_base64url(data_slice));
+#endif

     // FIXME: create a version of encode_base64url that omits padding bytes
     if (auto first_padding_byte = encoded.find_byte_offset('='); first_padding_byte.has_value())
@@ -104,7 +108,6 @@ ErrorOr<String> base64_url_uint_encode(::Crypto::UnsignedBigInteger integer)
 WebIDL::ExceptionOr<::Crypto::UnsignedBigInteger> base64_url_uint_decode(JS::Realm& realm, String const& base64_url_string)
 {
     auto& vm = realm.vm();
-    static_assert(AK::HostIsLittleEndian, "This code assumes little-endian");

     // FIXME: Create a version of decode_base64url that ignores padding inconsistencies
     auto padded_string = base64_url_string;
@@ -120,6 +123,7 @@ WebIDL::ExceptionOr<::Crypto::UnsignedBigInteger> base64_url_uint_decode(JS::Rea
     }
     auto base64_bytes = base64_bytes_or_error.release_value();

+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
     // We need to swap the integer's big-endian representation to little endian in order to import it
     Vector<u8, 32> byte_swapped_data;
     byte_swapped_data.ensure_capacity(base64_bytes.size());
@@ -127,6 +131,9 @@ WebIDL::ExceptionOr<::Crypto::UnsignedBigInteger> base64_url_uint_decode(JS::Rea
         byte_swapped_data.append(base64_bytes[base64_bytes.size() - i - 1]);

     return ::Crypto::UnsignedBigInteger::import_data(byte_swapped_data.data(), byte_swapped_data.size());
+#else
+    return ::Crypto::UnsignedBigInteger::import_data(base64_bytes.data(), base64_bytes.size());
+#endif
 }

 // https://w3c.github.io/webcrypto/#concept-parse-an-asn1-structure
diff --git a/Userland/Libraries/LibWeb/Crypto/KeyAlgorithms.cpp b/Userland/Libraries/LibWeb/Crypto/KeyAlgorithms.cpp
index fb3d018fd9..fabbce2869 100644
--- a/Userland/Libraries/LibWeb/Crypto/KeyAlgorithms.cpp
+++ b/Userland/Libraries/LibWeb/Crypto/KeyAlgorithms.cpp
@@ -90,8 +90,6 @@ void RsaKeyAlgorithm::visit_edges(Visitor& visitor)

 WebIDL::ExceptionOr<void> RsaKeyAlgorithm::set_public_exponent(::Crypto::UnsignedBigInteger exponent)
 {
-    static_assert(AK::HostIsLittleEndian, "This code assumes a little endian host");
-
     auto& realm = this->realm();
     auto& vm = this->vm();

@@ -103,6 +101,7 @@ WebIDL::ExceptionOr<void> RsaKeyAlgorithm::set_public_exponent(::Crypto::Unsigne

     // The BigInteger typedef from the WebCrypto spec requires the bytes in the Uint8Array be ordered in Big Endian

+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
     Vector<u8, 32> byte_swapped_data;
     byte_swapped_data.ensure_capacity(data_size);
     for (size_t i = 0; i < data_size; ++i)
@@ -110,6 +109,10 @@ WebIDL::ExceptionOr<void> RsaKeyAlgorithm::set_public_exponent(::Crypto::Unsigne

     m_public_exponent = TRY(JS::Uint8Array::create(realm, byte_swapped_data.size()));
     m_public_exponent->viewed_array_buffer()->buffer().overwrite(0, byte_swapped_data.data(), byte_swapped_data.size());
+#else
+    m_public_exponent = TRY(JS::Uint8Array::create(realm, data_slice.size()));
+    m_public_exponent->viewed_array_buffer()->buffer().overwrite(0, data_slice.data(), data_slice.size());
+#endif

     return {};
 }
