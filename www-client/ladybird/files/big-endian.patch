diff --git a/AK/StringBase.h b/AK/StringBase.h
index 541f7b8bdd..40eabf2d40 100644
--- a/AK/StringBase.h
+++ b/AK/StringBase.h
@@ -25,7 +25,6 @@ struct ShortString {
     u8 storage[MAX_SHORT_STRING_BYTE_COUNT] = { 0 };
 };

-static_assert(HostIsLittleEndian, "Order of fields in ShortString assumes LE.");
 static_assert(sizeof(ShortString) >= sizeof(StringData*));
 static_assert(__builtin_offsetof(ShortString, byte_count_and_short_string_flag) == 0);

diff --git a/Userland/Libraries/LibWeb/Crypto/CryptoAlgorithms.cpp b/Userland/Libraries/LibWeb/Crypto/CryptoAlgorithms.cpp
index cc485d8a4f..bbe1181c88 100644
--- a/Userland/Libraries/LibWeb/Crypto/CryptoAlgorithms.cpp
+++ b/Userland/Libraries/LibWeb/Crypto/CryptoAlgorithms.cpp
@@ -44,8 +44,6 @@ AlgorithmMethods::~AlgorithmMethods() = default;
 // https://w3c.github.io/webcrypto/#big-integer
 static ::Crypto::UnsignedBigInteger big_integer_from_api_big_integer(JS::GCPtr<JS::Uint8Array> const& big_integer)
 {
-    static_assert(AK::HostIsLittleEndian, "This method needs special treatment for BE");
-
     // The BigInteger typedef is a Uint8Array that holds an arbitrary magnitude unsigned integer
     // **in big-endian order**. Values read from the API SHALL have minimal typed array length
     // (that is, at most 7 leading zero bits, except the value 0 which shall have length 8 bits).
@@ -56,6 +54,7 @@ static ::Crypto::UnsignedBigInteger big_integer_from_api_big_integer(JS::GCPtr<J
     ::Crypto::UnsignedBigInteger result(0);
     if (buffer.size() > 0) {

+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
         // We need to reverse the buffer to get it into little-endian order
         Vector<u8, 32> reversed_buffer;
         reversed_buffer.resize(buffer.size());
@@ -64,6 +63,9 @@ static ::Crypto::UnsignedBigInteger big_integer_from_api_big_integer(JS::GCPtr<J
         }

         result = ::Crypto::UnsignedBigInteger::import_data(reversed_buffer.data(), reversed_buffer.size());
+#else
+        result = ::Crypto::UnsignedBigInteger::import_data(buffer.data(), buffer.size());
+#endif
     }
     return result;
 }
@@ -71,8 +73,6 @@ static ::Crypto::UnsignedBigInteger big_integer_from_api_big_integer(JS::GCPtr<J
 // https://www.rfc-editor.org/rfc/rfc7518#section-2
 ErrorOr<String> base64_url_uint_encode(::Crypto::UnsignedBigInteger integer)
 {
-    static_assert(AK::HostIsLittleEndian, "This code assumes little-endian");
-
     // The representation of a positive or zero integer value as the
     // base64url encoding of the value's unsigned big-endian
     // representation as an octet sequence.  The octet sequence MUST
@@ -87,6 +87,7 @@ ErrorOr<String> base64_url_uint_encode(::Crypto::UnsignedBigInteger integer)

     auto data_slice = bytes.bytes().slice(bytes.size() - data_size, data_size);

+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
     // We need to encode the integer's big endian representation as a base64 string
     Vector<u8, 32> byte_swapped_data;
     byte_swapped_data.ensure_capacity(data_size);
@@ -94,6 +95,9 @@ ErrorOr<String> base64_url_uint_encode(::Crypto::UnsignedBigInteger integer)
         byte_swapped_data.append(data_slice[data_size - i - 1]);

     auto encoded = TRY(encode_base64url(byte_swapped_data));
+#else
+    auto encoded = TRY(encode_base64url(data_slice));
+#endif

     // FIXME: create a version of encode_base64url that omits padding bytes
     if (auto first_padding_byte = encoded.find_byte_offset('='); first_padding_byte.has_value())
@@ -104,7 +108,6 @@ ErrorOr<String> base64_url_uint_encode(::Crypto::UnsignedBigInteger integer)
 WebIDL::ExceptionOr<::Crypto::UnsignedBigInteger> base64_url_uint_decode(JS::Realm& realm, String const& base64_url_string)
 {
     auto& vm = realm.vm();
-    static_assert(AK::HostIsLittleEndian, "This code assumes little-endian");

     // FIXME: Create a version of decode_base64url that ignores padding inconsistencies
     auto padded_string = base64_url_string;
@@ -120,6 +123,7 @@ WebIDL::ExceptionOr<::Crypto::UnsignedBigInteger> base64_url_uint_decode(JS::Rea
     }
     auto base64_bytes = base64_bytes_or_error.release_value();

+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
     // We need to swap the integer's big-endian representation to little endian in order to import it
     Vector<u8, 32> byte_swapped_data;
     byte_swapped_data.ensure_capacity(base64_bytes.size());
@@ -127,6 +131,9 @@ WebIDL::ExceptionOr<::Crypto::UnsignedBigInteger> base64_url_uint_decode(JS::Rea
         byte_swapped_data.append(base64_bytes[base64_bytes.size() - i - 1]);

     return ::Crypto::UnsignedBigInteger::import_data(byte_swapped_data.data(), byte_swapped_data.size());
+#else
+    return ::Crypto::UnsignedBigInteger::import_data(base64_bytes.data(), base64_bytes.size());
+#endif
 }

 // https://w3c.github.io/webcrypto/#concept-parse-an-asn1-structure
diff --git a/Userland/Libraries/LibWeb/Crypto/KeyAlgorithms.cpp b/Userland/Libraries/LibWeb/Crypto/KeyAlgorithms.cpp
index fb3d018fd9..fabbce2869 100644
--- a/Userland/Libraries/LibWeb/Crypto/KeyAlgorithms.cpp
+++ b/Userland/Libraries/LibWeb/Crypto/KeyAlgorithms.cpp
@@ -90,8 +90,6 @@ void RsaKeyAlgorithm::visit_edges(Visitor& visitor)

 WebIDL::ExceptionOr<void> RsaKeyAlgorithm::set_public_exponent(::Crypto::UnsignedBigInteger exponent)
 {
-    static_assert(AK::HostIsLittleEndian, "This code assumes a little endian host");
-
     auto& realm = this->realm();
     auto& vm = this->vm();

@@ -103,6 +101,7 @@ WebIDL::ExceptionOr<void> RsaKeyAlgorithm::set_public_exponent(::Crypto::Unsigne

     // The BigInteger typedef from the WebCrypto spec requires the bytes in the Uint8Array be ordered in Big Endian

+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
     Vector<u8, 32> byte_swapped_data;
     byte_swapped_data.ensure_capacity(data_size);
     for (size_t i = 0; i < data_size; ++i)
@@ -110,6 +109,10 @@ WebIDL::ExceptionOr<void> RsaKeyAlgorithm::set_public_exponent(::Crypto::Unsigne

     m_public_exponent = TRY(JS::Uint8Array::create(realm, byte_swapped_data.size()));
     m_public_exponent->viewed_array_buffer()->buffer().overwrite(0, byte_swapped_data.data(), byte_swapped_data.size());
+#else
+    m_public_exponent = TRY(JS::Uint8Array::create(realm, data_slice.size()));
+    m_public_exponent->viewed_array_buffer()->buffer().overwrite(0, data_slice.data(), data_slice.size());
+#endif

     return {};
 }
commit 480ddb937bc21a05d70f186bf2b875daf5792724
Author:     Dennis Camera <dennis.camera+ladybird@riiengineering.ch>
AuthorDate: Thu Jul 4 11:09:20 2024 +0200
Commit:     Dennis Camera <dennis.camera+ladybird@riiengineering.ch>
CommitDate: Thu Jul 4 21:22:00 2024 +0200

    AK: Implement floating-point conversions for big-endian

diff --git a/AK/FloatingPoint.h b/AK/FloatingPoint.h
index 3aa1a01e51..86bb813c97 100644
--- a/AK/FloatingPoint.h
+++ b/AK/FloatingPoint.h
@@ -25,9 +25,15 @@ union FloatExtractor<f128> {
     static constexpr int exponent_bits = 15;
     static constexpr unsigned exponent_max = 32767;
     struct [[gnu::packed]] {
+#    if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+        ComponentType sign : 1;
+        ComponentType exponent : 15;
+        ComponentType mantissa : 112;
+#    else
         ComponentType mantissa : 112;
         ComponentType exponent : 15;
         ComponentType sign : 1;
+#    endif
     };
     f128 d;
 };
@@ -51,9 +57,15 @@ union FloatExtractor<f80> {
         // However, since all bit-fiddling float code assumes IEEE floats, it cannot handle this properly.
         // If we pretend that 80-bit floats are IEEE floats with 64-bit mantissas, almost everything works correctly
         // and we just need a few special cases.
+#    if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+        ComponentType sign : 1;
+        ComponentType exponent : 15;
+        ComponentType mantissa : 64;
+#    else
         ComponentType mantissa : 64;
         ComponentType exponent : 15;
         ComponentType sign : 1;
+#    endif
     };
     f80 d;
 };
@@ -76,9 +88,15 @@ union FloatExtractor<f64> {
         //        very intuitive and portable behaviour on windows, but it doesn't
         //        work with the msvc ABI.
         //        See <https://github.com/llvm/llvm-project/issues/24757>
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+        ComponentType sign : 1;
+        ComponentType exponent : 11;
+        ComponentType mantissa : 52;
+#else
         ComponentType mantissa : 52;
         ComponentType exponent : 11;
         ComponentType sign : 1;
+#endif
     };
     f64 d;
 };
@@ -93,9 +111,15 @@ union FloatExtractor<f32> {
     static constexpr int exponent_bits = 8;
     static constexpr ComponentType exponent_max = 255;
     struct [[gnu::packed]] {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+        ComponentType sign : 1;
+        ComponentType exponent : 8;
+        ComponentType mantissa : 23;
+#else
         ComponentType mantissa : 23;
         ComponentType exponent : 8;
         ComponentType sign : 1;
+#endif
     };
     f32 d;
 };
diff --git a/AK/FloatingPointStringConversions.cpp b/AK/FloatingPointStringConversions.cpp
index 9298d62241..9fea3f9cda 100644
--- a/AK/FloatingPointStringConversions.cpp
+++ b/AK/FloatingPointStringConversions.cpp
@@ -176,8 +176,6 @@ static constexpr auto max_representable_power_of_ten_in_u64 = 19;
 static_assert(1e19 <= static_cast<double>(NumericLimits<u64>::max()));
 static_assert(1e20 >= static_cast<double>(NumericLimits<u64>::max()));
 
-static_assert(HostIsLittleEndian, "Float parsing currently assumes little endian, this fact is only used in fast parsing of 8 digits at a time"
-                                  "\nyou _should_ only need to change read eight_digits to make this big endian compatible.");
 constexpr u64 read_eight_digits(char const* string)
 {
     u64 val;
@@ -206,40 +204,57 @@ constexpr static u32 eight_digits_to_value(u64 value)
 {
     // THIS DOES ABSOLUTELY ASSUME has_eight_digits is true
 
-    // This trick is based on https://johnnylee-sde.github.io/Fast-numeric-string-to-int/
-    // FIXME: fast_float uses a slightly different version, but that is far harder
-    //        to understand and does not seem to improve performance substantially.
-    //        See https://github.com/fastfloat/fast_float/pull/28
+    if constexpr (AK::HostIsLittleEndian) {
+        // This trick is based on https://johnnylee-sde.github.io/Fast-numeric-string-to-int/
+        // FIXME: fast_float uses a slightly different version, but that is far harder
+        //        to understand and does not seem to improve performance substantially.
+        //        See https://github.com/fastfloat/fast_float/pull/28
 
-    // First convert the digits to their respectively numbers (0x30 -> 0x00 etc.)
-    value -= 0x3030303030303030;
+        // First convert the digits to their respectively numbers (0x30 -> 0x00 etc.)
+        value -= 0x3030303030303030;
 
-    // Because of little endian the first number will in fact be the least significant
-    // bits of value i.e. "12345678" -> 0x0807060504030201
-    // This means that we need to shift/multiply each digit with 8 - the byte it is in
-    // So the eight need to go down, and the 01 need to be multiplied with 10000000
+        // Because of little endian the first number will in fact be the least significant
+        // bits of value i.e. "12345678" -> 0x0807060504030201
+        // This means that we need to shift/multiply each digit with 8 - the byte it is in
+        // So the eight need to go down, and the 01 need to be multiplied with 10000000
 
-    // We effectively multiply by 10 and then shift those values to the right (2^8 = 256)
-    // We then shift the values back down, this leads to 4 digits pairs in the 2 byte parts
-    // The values between are "garbage" which we will ignore
-    value = (value * (256 * 10 + 1)) >> 8;
-    // So with our example this gives 0x$$4e$$38$$22$$0c, where $$ is garbage/ignored
-    // In decimal this gives              78  56  34  12
+        // We effectively multiply by 10 and then shift those values to the right (2^8 = 256)
+        // We then shift the values back down, this leads to 4 digits pairs in the 2 byte parts
+        // The values between are "garbage" which we will ignore
+        value = (value * (256 * 10 + 1)) >> 8;
+        // So with our example this gives 0x$$4e$$38$$22$$0c, where $$ is garbage/ignored
+        // In decimal this gives              78  56  34  12
 
-    // Now we keep performing the same trick twice more
-    // First * 100 and shift of 16 (2^16 = 65536) and then shift back
-    value = ((value & 0x00FF00FF00FF00FF) * (65536 * 100 + 1)) >> 16;
+        // Now we keep performing the same trick twice more
+        // First * 100 and shift of 16 (2^16 = 65536) and then shift back
+        value = ((value & 0x00FF00FF00FF00FF) * (65536 * 100 + 1)) >> 16;
 
-    // Again with our example this gives 0x$$$$162e$$$$04d2
-    //                                         5678    1234
+        // Again with our example this gives 0x$$$$162e$$$$04d2
+        //                                         5678    1234
 
-    // And finally with * 10000 and shift of 32 (2^32 = 4294967296)
-    value = ((value & 0x0000FFFF0000FFFF) * (4294967296 * 10000 + 1)) >> 32;
+        // And finally with * 10000 and shift of 32 (2^32 = 4294967296)
+        value = ((value & 0x0000FFFF0000FFFF) * (4294967296 * 10000 + 1)) >> 32;
 
-    // With the example this gives 0x$$$$$$$$00bc614e
-    //                                       12345678
-    // Now we just truncate to the lower part
-    return u32(value);
+        // With the example this gives 0x$$$$$$$$00bc614e
+        //                                       12345678
+
+        // Now we just truncate to the lower part
+        return u32(value);
+    } else {
+        value -= 0x3030303030303030;
+
+        value = (value & 0x0fL)
+            + ((value & (0x0fL << 8)) >> 8) * 10
+            + ((value & (0x0fL << 16)) >> 16) * 100
+            + ((value & (0x0fL << 24)) >> 24) * 1000
+            + ((value & (0x0fL << 32)) >> 32) * 10000
+            + ((value & (0x0fL << 40)) >> 40) * 100000
+            + ((value & (0x0fL << 48)) >> 48) * 1000000
+            + ((value & (0x0fL << 56)) >> 56) * 10000000;
+
+        // Now we just truncate to the lower part
+        return u32(value);
+    }
 }
 
 template<typename IsDoneCallback, typename Has8CharsLeftCallback>
diff --git a/AK/Math.h b/AK/Math.h
index 1a354a7488..fe6c0c3d35 100644
--- a/AK/Math.h
+++ b/AK/Math.h
@@ -8,6 +8,7 @@
 
 #include <AK/BuiltinWrappers.h>
 #include <AK/Concepts.h>
+#include <AK/Endian.h>
 #include <AK/FloatingPoint.h>
 #include <AK/NumericLimits.h>
 #include <AK/StdLibExtraDetails.h>
@@ -765,14 +766,21 @@ constexpr T log2(T x)
 
     // FIXME: Handle denormalized numbers separately
 
-    FloatExtractor<T> mantissa_ext {
-        .mantissa = ext.mantissa,
-        .exponent = FloatExtractor<T>::exponent_bias,
-        .sign = ext.sign
-    };
-
     // (1 <= mantissa < 2)
-    T m = mantissa_ext.d;
+    T m;
+    if constexpr (HostIsLittleEndian) {
+        m = ((FloatExtractor<T>) {
+                 .mantissa = ext.mantissa,
+                 .exponent = FloatExtractor<T>::exponent_bias,
+                 .sign = ext.sign })
+                .d;
+    } else {
+        m = ((FloatExtractor<T>) {
+                 .sign = ext.sign,
+                 .exponent = FloatExtractor<T>::exponent_bias,
+                 .mantissa = ext.mantissa })
+                .d;
+    }
 
     // This is a reconstruction of one of Sun's algorithms
     // They use a transformation to lower the problem space,
